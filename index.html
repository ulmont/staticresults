<!DOCTYPE html>
<html>
<head>
	<style>
		#controlsDiv {
			height: 40px;
			background-color: #222266"
		}
		#tName {
			font-size: 1.5em; 
			font-weight: bold;
			margin: 0;
		}
		#tDate {
			margin: 0;
		}
		table tr:nth-child(even) {
			background-color: #00bbFF;
		}
		/*
		** The drop downs are arranged as a table with no borders
		*/
		table.ControlOuter th,
		table.ControlOuter td {
			padding: 5px;
		}
		tbody div {
			overflow-y: auto;
			scrollbar-gutter: stable;
			height: auto;
		}
		th.Board, td.Board {
			width: auto;
			padding: 3px;
		}
		th.Board, th.Number {
			text-align: left;
		}
		td.Board {
			text-align: right;
		}
		th.Score, td.Score {
			width: auto;
			padding: 3px;
		}
		th.Name, td.Name {
			width: auto;
			padding: 3px;
			text-align: left;
		}
	</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip-utils/0.1.0/jszip-utils.min.js"></script>
<script type="text/javascript">

var tourney;
var vTable;
function TestShow(ptozOrSJSON)
{
	tourney = ptozOrSJSON;
	vTable = tourney.vTable;
	SetupGlobals();
	SetupControls();
}

function SetupGlobals() 
{
	// update the title etc.
	document.getElementById('tName').innerText = vTable.getTitle(tourney);
	document.getElementById('tDate').innerText = vTable.getDate(tourney);
}

function SetupControls()
{
	const controlsDiv = document.getElementById('controlsDiv');
	controlsDiv.innerHTML = "<table class='ControlOuter' style='width: 100%;'><tr><td id='chartsBox'></td><td id='sectionBox'></td><td id='roundsBox'></td></tr></table>";

	SetupCharts();
}

function SetupCharts()
{
	const chartsElement = document.getElementById('chartsBox');
	let chartsBox;
	chartsBox = `Charts:<select id='chartsDD' onchange='onChartsChange()'>
		<option value="Pairings">Pairings</option>
		<option value="Wall Chart">Wall Chart</option>
		<option value="Standings">Standings</option>
	</select>`;

	chartsElement.innerHTML = chartsBox;
	document.getElementById("chartsDD").selectedIndex = 0;

	onChartsChange();
}

function onChartsChange()
{
	// just always setup the Sections and let the Section switch figure out what to display after that
	SetupSections();
}

function onSectionChange()
{
	let section = getSection();
	SetupRounds(vTable.getSectionRoundsPaired(section));
}

function SetupSections()
{
	const sections = vTable.getSections(tourney);
	const sectionsElement = document.getElementById('sectionBox');
	let sectionBox;
	if (sections.length === 1) {
		// special case the single-section (Open, typically) event
		sectionBox = `Section: ${vTable.getSectionTitle(sections[0])}`;
		sectionsElement.innerHTML = sectionBox;
	} else {
		sectionBox = "Section:<select id='sectionDD' onchange='onSectionChange()'>";
		for (let i = 0; i < sections.length; i++) {
			//
			//	Skip any sections which have no paired rounds
			//
			if (sections[i].roundsPaired == 0)
				continue;
			const sectionValue = `<option value=${i}>${vTable.getSectionTitle(sections[i])}</option>`;
			sectionBox = `${sectionBox}${sectionValue}`;
		}
		sectionBox = `${sectionBox}
		</select>`;
		//
		//	Pick the first section in the list as the default and force
		//	the section change to update the rounds box
		//
		sectionsElement.innerHTML = sectionBox;
		document.getElementById("sectionDD").selectedIndex = 0;
	}

	onSectionChange();
}

function getSection() 
{
	const sections = vTable.getSections(tourney);
	if (sections.length === 1) {
		return sections[0];
	} else {
		let sectionDD = document.getElementById("sectionDD");
		let sectionsValue = sectionDD.options[sectionDD.selectedIndex].value;
		let section = sections[sectionsValue];
		return section;
	}
}

function onSectionChange()
{
	const section = getSection();
	const chartsDD = document.getElementById("chartsDD");
	const chartsValue = chartsDD.options[chartsDD.selectedIndex].value;

	switch (chartsValue) {
		case 'Pairings':
			SetupRounds(vTable.getSectionRoundsPaired(section));
			break;
		case 'Wall Chart':
			SetupWallChart(section, sortPlayersByPairNo, vTable.getPlayerPairNo, getColorString);
			break;
		case 'Standings':
			SetupWallChart(section, sortPlayersByScoreTiebreaks, getPlayerIndex, vTable.getResultString);
			break;
		default:
			SetupRounds(vTable.getSectionRoundsPaired(section));
			break;
	}
}

function sortPlayersByPairNo(a, b)
{
	if (vTable.getPlayerPairNo(a) < vTable.getPlayerPairNo(b)) {
		return -1; // lower pairing number sorts first
	}

	if (vTable.getPlayerPairNo(a) > vTable.getPlayerPairNo(b)) {
		return 1; // higher pairing number sorts last
	}

	return 0; // shouldn't happen for pairing numbers
}

function sortPlayersByScoreTiebreaks(a, b)
{
	const aPts = vTable.getPlayerPoints(a);
	const bPts = vTable.getPlayerPoints(b);
	if (aPts > bPts) {
		return -1; // higher score sorts first
	}

	if (aPts < bPts) {
		return 1; // lower score sorts last
	}

	console.log('Score: ' + aPts + ' is equal for ' + vTable.getPlayerName(a) + ' and ' + vTable.getPlayerName(b) + ' moving to Modified Median');

	/* 34E
	Unless a different method has been posted or announced before the start of the first round, players will expect the following sequence of tiebreak systems to be employed as the first four tiebreakers. 
	1. Modified Median
	2. Solkoff
	3. Cumulative
	4. Cumulative of Opposition
	*/

	const aMM = calcModifiedMedian(a);
	const bMM = calcModifiedMedian(b);
	// console.log('Modified Median: ' + aMM + ' for ' + vTable.getPlayerName(a) + ' vs ' + bMM + ' for ' + vTable.getPlayerName(b));
	if (aMM > bMM) {
		return -1; // higher sorts first
	}

	if (aMM < bMM) {
		return 1; // lower sorts last
	}

	console.log('Modified Median: ' + aMM + ' is equal for ' + vTable.getPlayerName(a) + ' and ' + vTable.getPlayerName(b) + ' moving to Solkoff');
	const aS = calcSolkoff(a);
	const bS = calcSolkoff(b);
	// console.log('Solkoff: ' + aS + ' for ' + vTable.getPlayerName(a) + ' vs ' + bS + ' for ' + vTable.getPlayerName(b));
	if (aS > bS) {
		return -1; // higher sorts first
	}

	if (aS < bS) {
		return 1; // lower sorts last
	}

	console.log('Solkoff: ' + aS + ' is equal for ' + vTable.getPlayerName(a) + ' and ' + vTable.getPlayerName(b) + ' moving to Cumulative');

	// Cumulative
	const aC = calcCumulative(a);
	const bC = calcCumulative(b);
    console.log('Cumulative: ' + aC + ' for ' + vTable.getPlayerName(a) + ' vs ' + bC + ' for ' + vTable.getPlayerName(b));
	if (aC > bC) {
		return -1; // higher sorts first
	}

	if (aC < bC) {
		return 1; // lower sorts last
	}
	console.log('Cumulative: ' + aC + ' is equal for ' + vTable.getPlayerName(a) + ' and ' + vTable.getPlayerName(b) + ' moving to Cumulative of Opposition');

	// Cumulative of Opposition
	const aCO = calcCumulativeOfOpposition(a);
	const bCO = calcCumulativeOfOpposition(b);
    console.log('Cumulative of Opposition: ' + aCO + ' for ' + vTable.getPlayerName(a) + ' vs ' + bCO + ' for ' + vTable.getPlayerName(b));
	if (aCO > bCO) {
		return -1; // higher sorts first
	}

	if (aCO < bCO) {
		return 1; // lower sorts last
	}
	console.log('Cumulative of Opposition: ' + aCO + ' is equal for ' + vTable.getPlayerName(a) + ' and ' + vTable.getPlayerName(b) + ' out of tiebreakers');

	return 0;
}

function calcCumulativeOfOpposition(player)
{
	/*34E9. Cumulative scores of opposition.
	The cumulative tiebreak points of each opponent are calculated as in 34E3 and these are added together.*/
	
	let opponentScores = 0.0;
	const opponents = vTable.getOpponents(player);
	opponents.forEach(opponent => {
		if (opponent !== null) {
			const oppScore = calcCumulative(opponent);
			opponentScores = opponentScores + oppScore;
		} else {
			// unplayed game, counts as a 0 score.
		}
	});

	return opponentScores;
}

function calcCumulative(player)
{
	/*34E3. Cumulative.
	To determine cumulative tiebreak score, simply add up the cumulative (running) score for each round. For example, if a player’s results were win, loss, win, draw, loss, the wall chart would show a cumulative score round by round as 1, 1, 2, 2.5, 2.5. The cumulative tiebreak total is 9 (1+1+2+2.5+2.5 = 9). If another player scored 2.5 with a sequence 1, 2, 2.5, 2.5, 2.5, the tiebreak points scored would be 10.5 (1+2+2.5+2.5+2.5 = 10.5). The latter player’s tiebreaks are higher because he or she scored earlier and presumably had tougher opposition for the remainder of the event. One point is subtracted from the sum for each unplayed win or full-point bye (22B); likewise, one-half point is subtracted from the sum for each unplayed draw or half-point bye.*/
	let playerScores = vTable.calcCumulativePlayerScores(player);
	let s = 0.0;
	playerScores.forEach(score => {
		s = s + score;
	});

	return s;
}

function calcSolkoff(player) 
{

	/*34E2. Solkoff.
	The Solkoff system is the same as the Median system (34E1) except that no opponents’ scores are discarded.
	The Median system, also known as the Harkness system for inventor Kenneth Harkness, evaluates the strength of a player’s opposition by summing the final scores of his or her opponents and then discarding the highest and lowest of these scores.
	...
	These scores are adjusted for unplayed games, which count a half point each, regardless of whether they were byes, forfeits, or simply rounds not played after an opponent withdrew. So an opponent who won the first two games, lost the third, withdrew and did not play rounds four or five would have an adjusted score of 3 points (1+1+0+0.5+0.5 = 3). These adjusted scores are used only to calculate the opponent’s tiebreaks. The player’s own score is not changed.

	If the player involved in the tie has any unplayed games, they count as opponents with adjusted scores of 0.
	*/
	let opponentScores = calcOpponentScores(player);
	// console.log('opponents scores: ' + opponentScores);

	// The Solkoff system is the same as the Median system (34E1) except that no opponents’ scores are discarded.
	let s = 0.0;
	opponentScores.forEach(score => {
		s = s + score;
	});

	return s;
}

function calcModifiedMedian(player) 
{
	const section = getSection();

	/*34E1. Modified Median
	The Median system, also known as the Harkness system for inventor Kenneth Harkness, evaluates the strength of a player’s opposition by summing the final scores of his or her opponents and then discarding the highest and lowest of these scores.

	In the Modified Median system, players who tie with even scores (an even score is equal to exactly one half of the maximum possible score), have the highest- and lowest-scoring opponents’ scores excluded. The system is modified for players with non-even scores to disregard only the least significant opponents’ scores: the lowest-scoring opponent’s score is discarded for tied players with plus scores and the highest-scoring for tied players with minus scores.

	For tournaments of nine or more rounds, the top two and bottom two scores are discarded for even-score ties, the bottom two scores for plus-score ties, and the top two scores for minus-score ties.

	These scores are adjusted for unplayed games, which count a half point each, regardless of whether they were byes, forfeits, or simply rounds not played after an opponent withdrew. So an opponent who won the first two games, lost the third, withdrew and did not play rounds four or five would have an adjusted score of 3 points (1+1+0+0.5+0.5 = 3). These adjusted scores are used only to calculate the opponent’s tiebreaks. The player’s own score is not changed.

	If the player involved in the tie has any unplayed games, they count as opponents with adjusted scores of 0.*/

	let opponentScores = calcOpponentScores(player);
	// console.log('opponents scores pre-slice: ' + opponentScores);

	const even = vTable.getSectionRoundsPaired(section) / 2.0; // (an even score is equal to exactly one half of the maximum possible score)
	if (vTable.getPlayerPoints(player) === even) {
		// console.log(vTable.getPlayerPoints(player) + ' in ' + vTable.getSectionRoundsPaired(section) + ' is an even score');
		// players who tie with even scores (an even score is equal to exactly one half of the maximum possible score), have the highest- and lowest-scoring opponents’ scores excluded.
		// but don't bother after rounds 1-2 or if somehow we don't have 3 scores listed
		if ((vTable.getSectionRoundsPaired(section) > 2) && (opponentScores.length > 2)) {
			opponentScores = opponentScores.slice(1, -1);
		}
		// For tournaments of nine or more rounds, the top two and bottom two scores are discarded for even-score ties
		// but don't bother if somehow we don't still have 3 scores listed.
		if ((vTable.getSectionRoundsPaired(section) > 8) && (opponentScores.length > 2)) {
			opponentScores = opponentScores.slice(1, -1);
		}
	} else if (vTable.getPlayerPoints(player) > even) {
		// console.log(vTable.getPlayerPoints(player) + ' in ' + vTable.getSectionRoundsPaired(section) + ' is a plus score');
		// the lowest-scoring opponent’s score is discarded for tied players with plus scores
		// but don't bother after rounds 1-2 or if somehow we don't have 3 scores listed
		if ((vTable.getSectionRoundsPaired(section) > 2) && (opponentScores.length > 2)) {
			opponentScores.shift();
		}
		// the bottom two scores for plus-score ties
		// but don't bother if somehow we don't still have 3 scores listed.
		if ((vTable.getSectionRoundsPaired(section) > 8) && (opponentScores.length > 2)) {
			opponentScores.shift();
		}
	} else {
		// console.log(vTable.getPlayerPoints(player) + ' in ' + vTable.getSectionRoundsPaired(section) + ' is a minus score');
		// the highest-scoring for tied players with minus scores
		// but don't bother after rounds 1-2 or if somehow we don't have 3 scores listed
		if ((vTable.getSectionRoundsPaired(section) > 2) && (opponentScores.length > 2)) {
			opponentScores.pop();
		}
		// the top two scores for minus-score ties.
		// but don't bother if somehow we don't still have 3 scores listed.
		if ((vTable.getSectionRoundsPaired(section) > 8) && (opponentScores.length > 2)) {
			opponentScores.pop();
		}
	}

	// console.log('opponents scores post-slice: ' + opponentScores);
	let mm = 0.0;
	opponentScores.forEach(score => {
		mm = mm + score;
	});

	return mm;
}

function calcPlayerScores(player)
{
	let playerScores = [];

	return playerScores;
}

function calcOpponentScores(player)
{
	let opponentScores = [];
	const opponents = vTable.getOpponents(player);
	opponents.forEach(opponent => {
		if (opponent !== null) {
			const oppScore = vTable.calcMMAdjustedScore(opponent);
			opponentScores.push(oppScore);
		} else {
			opponentScores.push(0); // unplayed game, counts as a 0 score.
		}
	});

	// sort scores low to high
	opponentScores.sort((a, b) => {
		return a - b;
	});
	// console.log('opponents scores pre-slice: ' + opponentScores);

	return opponentScores;
}

function getPlayerIndex(player, sectionPlayers)
{
	const index = sectionPlayers.findIndex((element) => {
		return (vTable.getPlayerPairNo(element) === vTable.getPlayerPairNo(player));
	});
	
	return (index + 1);
}

function getColorString(color, result)
{
	return color;
}

function SetupWallChart(section, sortAlgo, playerNumAlgo, colorStringAlgo) 
{
	const sectionPlayers = vTable.getSectionPlayers(vTable.getSectionId(section));
	const playersToShow = sectionPlayers.sort(sortAlgo);

	// hide the the pairings table
	document.getElementById('pairingsDiv').style.display = 'none';
	// and also hide the round box
	document.getElementById('roundsBox').style.display = 'none'

	/*
		Wall Chart		
	# 	Name			Rds 1...n	Total
		Rating / ID		win / loss
	1	Campbell, Charles Adegboyega	W  19	B  10	W   8	B   2	B   3	4.5
	2198      14497790	1	2	2.5	3.5	4.5
	*/
	const wallChartDiv = document.getElementById('wallChartDiv');
	let pTable = `<table id="GLOuter" style='width: 100%;'>
		<thead>
			<tr>
				<th class="Number">#</th>
				<th class="Name">Name<br />Rating / ID</th>`;
	for (let i = 0 ; i < vTable.getSectionRoundsPaired(section) ; i++) {
		pTable = `${pTable}
				<th class="Score">Rd ${i+1}</th>`;
	}
	pTable = `${pTable}
			<th class="Score">Total</th>
			<th class="Score">Performance</th>
		</tr>
	</thead>
	<tbody>`;

	for (const [i, player] of playersToShow.entries()) {
		let oppRatings = [];
		let score = 0.0;
		let playedScore = 0.0;
		let playerId = vTable.getPlayerId(player);
		let playerIdLink = (playerId.length > 0) ? `<a href=https://www.uschess.org/msa/MbrDtlMain.php?${playerId}>${playerId}</a>` : '';
		pTable = `${pTable}		
			<tr>
				<td class="Number">${playerNumAlgo(player, sectionPlayers)}</td>
				<td class="Name">${vTable.getPlayerName(player)}<br />${vTable.getPlayerRating(player, section)}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />${playerIdLink}</td>`;
		for (let j = 0; j < vTable.getSectionRoundsPaired(section); j++) {
			let [roundScore, colorString, playerNum, byeType, isBye, oppRating] = vTable.calcScoreColorStringPlayerNumByeTypeIsByeOppRating(j, section, sectionPlayers, player, playerNumAlgo, colorStringAlgo);
			score = score + roundScore;
			if (!isBye) { 
				pTable = `${pTable}
					<td class="Name">${colorString}&nbsp;&nbsp${playerNum}<br />${score}</td>`;
				if (!isNaN(oppRating)) { // that is, wasn't a game against an unrated player
					oppRatings.push(oppRating);
					playedScore = playedScore + roundScore;
				}
			} else {
				pTable = `${pTable}
					<td class="Name">${byeType}<br />${score}</td>`;
			}
		}
		pTable = `${pTable}
			<td class="Score">${score.toFixed(1)}</td>`;
		if (oppRatings.length > 0) {
			let perf = calcPerformanceRating(player, section, oppRatings, playedScore);
			if (playedScore === oppRatings.length) { // perfect score, give at least +50 if they have a rating
				if (vTable.getPlayerRating(player, section) !== 'Unr') {
					perf = Math.max(perf, vTable.getPlayerRating(player, section) + 50);
				}
			}
			pTable = `${pTable}
				<td class="Score">${(perf).toFixed(0)}</td>`;
		} else {
			pTable = `${pTable}
				<td class="Score">N/A</td>`;
		}
		pTable = `${pTable}
		</tr>`;
	}
	wallChartDiv.innerHTML = `${pTable}
			</tbody>
		</table>`;
	wallChartDiv.style.display = 'block';
}

function calcPerformanceRating(player, section, oppRatings, playedScore) {
	// iterate here until we figure out the correct rating to roughly match the result
	// just start with a guess of either the current rating, if they have one, or their average opponent rating if they don't
	let oppTotal = 0;
	oppRatings.forEach(oppRating => {
		oppTotal = oppTotal + oppRating;
	});
	const oppAverage = oppTotal / oppRatings.length;
	let perfLow = Math.floor(oppAverage - 400); // at this point you'd be expected to lose each game.
	let perfHigh = Math.ceil(oppAverage + 400); // at this point you'd be expected to win each game.
	let perf = vTable.getPlayerRating(player, section);
	if (perf === 'Unr') {
		perf = oppAverage;
	}
	// clip the rating into the low-high range if necessary
	perf = Math.max(perfLow, perf);
	pref = Math.min(perfHigh, perf);
	const epsilon = Math.pow(10, -4);
	let provExpectancies = calcProvisionalWinningExpectancies(perf, oppRatings);
	let diff = provExpectancies - playedScore;
	let delta = Math.abs(diff);
	while (delta > epsilon) {
		console.log(`score ${playedScore} estimate ${provExpectancies} low ${perfLow} perf ${perf} high ${perfHigh} diff ${diff} `);
		let oldPerf = perf;
		if (diff > 0) {
			// make this the new high water mark
			perfHigh = perf;
		} else {
			// make this the new low water mark
			perfLow = perf;
		}
		// next guess averages our new bounds
		perf = (perfHigh + perfLow) / 2;
		if (Math.abs(oldPerf - perf) < 2) {
			// this is about as good as we can do, bail out
			break;
		}
		provExpectancies = calcProvisionalWinningExpectancies(perf, oppRatings);
		diff = provExpectancies - playedScore;
		delta = Math.abs(diff);
	}
	if (perf < 100) { // can't go below 100
		perf = 100;
	}

	return perf;
}

// formula from approximating formulas for the US Chess Rating System
function calcProvisionalWinningExpectancies(rating, oppRatings) {
	let total = 0;
	oppRatings.forEach(oppRating => {
		// provisional winning expectancy is 0 if the opponent is 400+ higher, 1 if the opponent is 400+ lower, or a calculation
		const diff = rating - oppRating;
		const power = (0 - diff)/400;
		const tenPart = Math.pow(10, power);
		const denom = tenPart + 1;
		const chance = 1 / denom;
		total = total + chance;
	});
	return total;
}

// formula from Section 4.1 of the rating formula
/* function calcProvisionalWinningExpectancies(rating, oppRatings) {
	let total = 0;
	oppRatings.forEach(oppRating => {
		// provisional winning expectancy is 0 if the opponent is 400+ higher, 1 if the opponent is 400+ lower, or a calculation
		const diff = rating - oppRating;
		if (diff <= -400) { 
			total = total + 0.0; // no chance
		} else if (diff >= 400) {
			total = total + 1.0; // no chance the other way.
		} else {
			total = total + 0.5 + (diff / 800.0); // calculation
		}
	});
	return total;
}
 */
function SetupRounds(sectionRounds)
{
	// hide the wall chart table
	document.getElementById('wallChartDiv').style.display = 'none';

	// add the round box
	const roundsElement = document.getElementById('roundsBox');
	let roundsBox = "Round:<select id='roundsDD' onchange='onRoundsChange()'>";
	for (let i = 1; i <= sectionRounds; i++) {
		const roundsValue = `<option value=${i}>${i}`;
		roundsBox += roundsValue;
	}
	console.log(roundsBox);
	roundsElement.innerHTML = roundsBox;
	roundsElement.style.display = 'block'

	//	Select the highest round paired
	//
	document.getElementById("roundsDD").selectedIndex = sectionRounds - 1;
	onRoundsChange();
}

function onRoundsChange()
{
	//
	//	These will be the round number (1,...,roundsPaired) and the section index in the
	//	sections array.
	//
	let roundsDD	= document.getElementById("roundsDD");
	let roundsValue = roundsDD.options[roundsDD.selectedIndex].value;
	let section = getSection();

	vTable.ShowPairings(section, roundsValue);
}

function PullGames(sectionID, round)
//
//	Pull the list of game numbers for a section and round
//
{
	const players = tourney.players;
	gamelist = [];
	for (let i=0 ; i < players.length ; i++) {
		player = players[i];
		//
		// skip if player is not in the section
		//
		if (player["tnmt"]["sectionID"] != sectionID)
			continue;
		//
		//	This is a list of game numbers. -1 means no game for a round
		//
		playerGames = player["tnmt"]["games"];
		//
		// skip if player has no game for this round (either the round is out-of-range or the game number is -1)
		//
		if (round > playerGames.length)
			continue;
		if (playerGames[round-1] == -1 || playerGames[round-1] == null)
			continue;
		console.log(player["base"].name);
		console.log(playerGames[round-1]);
		gamelist.push(playerGames[round-1]);
	}
	console.log(gamelist);
	return gamelist;
}

function GameBoard(game)
//
//	If there is only one player record (for a bye), make the board -1
//
{
	if (game["p1"] == -1 || game["p2"] == -1)
		return -1;
	else
		return game["board"];
}

function GameBoardShow(game)
{
	if (GameBoard(game) == -1)
		return "";
	else
		return GameBoard(game);
}

function GameLeftPlayer(game)
//
//  Get the player number for the player who should be left/white column
//	If the game is a bye, left column should be whichever record is live.
//
{
	if (game["p2"] == -1)
		return game["p1"];
	if (game["p1"] == -1)
		return game["p2"];

	if (game["color1"] == +1)
		return game["p1"];
	else
		return game["p2"];
}

function GameRightPlayer(game)
//
// Get the player number for the player who should be right/black column
//
{
	if (game["p2"] == -1 || game["p1"] == -1)
		return -1;

	if (game["color1"] == +1)
		return game["p2"];
	else
		return game["p1"];
}

function GameResultP1(result)
//
//	Get the string result for player 1
//
{
	if (result == 0)
		return "0.5";
	else if (result == +1 || result == +3)
		return "1.0";
	else if (result == -1)
		return "0.0";
	else if (result == +2)
		return "1.0F";
	else if (result == -2 || result == -98)
		return "0.0F";
	else
		return "   ";
}

function GameResultP2(result) {
	if (result == 0)
		return "0.5";
	else if (result == -1)
		return "1.0";
	else if (result == +1)
		return "0.0";
	else if (result == -2)
		return "1.0F";
	else if (result == +2 || result == -98)
		return "0.0F";
	else
		return "";
}

function GameLeftResult(game)
{
	result = game["result"];
	if (game["color1"] == +1 || game["p2"] == -1)
		return GameResultP1(result);
	else
		return GameResultP2(result);
}

function GameRightResult(game)
{
	if (GameRightPlayer(game) == -1)
		return "   ";
	result = game["result"];
	if (game["color1"] == +1)
		return GameResultP2(result);
	else
		return GameResultP1(result);
}

function PlayerFormat(pnumber)
{
	if (pnumber==-1)
		return "Bye";
	return tourney.players[pnumber]["base"]["name"];
}

function ShowPairingsPTOZ(section, rp)
{
//
//	pull array[int] of game numbers and sort by board number, but bubble -1's (byes)
//	to the end
//
	gamelist = PullGames(section["id"],rp);
	gamelist.sort(function(a,b) {
		let aBd = GameBoard(tourney.games[a]);
		let bBd = GameBoard(tourney.games[b]);
		if (aBd == -1 && bBd == -1)
			return 0;
		if (aBd == -1)
			return +1;
		if (bBd == -1)
			return -1;
		else
			return aBd - bBd;
	});
	const pairingsDiv = document.getElementById('pairingsDiv');
	//
	//	The table of games consists of an outer table with the header and an
	//	inner table with the game list, which is embedded in a scrolling div.
	//
	let pTable = `<table id="GLOuter" style='width: 100%;'>
		<thead>
			<tr>
				<th class="Board">Board</th>
				<th class="Score">Scr</th>
				<th class="Name">White</th>
				<th class="Score">Scr</th>
				<th class="Name">Black</th>
			</tr>
		</thead>
		<tbody>`;
	for (let j = 0 ; j < gamelist.length ; j++) {
		//
		//	The above will double up on games with two players, so only show the
		//	first of the two.
		//
		console.log(gamelist[j]);
		if (j > 0 && gamelist[j] == gamelist[j - 1])
			continue;
		boardRec    = gamelist[j];
		game        = tourney.games[boardRec];
		board       = GameBoardShow(game);
		leftPlayer  = GameLeftPlayer(game);
		rightPlayer = GameRightPlayer(game);
		leftName    = PlayerFormat(leftPlayer);
		leftResult  = GameLeftResult(game);
		leftPoints = vTable.getPlayerPoints(tourney.players[leftPlayer], rp);
		rightName   = PlayerFormat(rightPlayer);
		rightResult = GameRightResult(game);
		rightPoints = vTable.getPlayerPoints(tourney.players[rightPlayer], rp);
		if (leftPoints !== undefined) {
			leftPoints = '(' + leftPoints.toFixed(1) + ')';
		} else {
			leftPoints = '';
		}
		if (rightPoints !== undefined) {
			rightPoints = '(' + rightPoints.toFixed(1) + ')';
		} else {
			rightPoints = '';
		}
		resultLine = `<tr>
			<td class="Board">${board}</td>
			<td class="Score">${leftResult} ${leftPoints}</td>
			<td class="Name">${leftName}</td>
			<td class="Score">${rightResult} ${rightPoints}</td>
			<td class="Name">${rightName}</td>
		</tr>`;
		pTable += resultLine;
	}
	pairingsDiv.innerHTML = `${pTable}
			</tbody>
		</table>`;
	pairingsDiv.style.display = 'block';
}

function ShowPairingsSJSON(section,rp)
{
	let gameResults = [];
	section.Players.forEach(player => {
		let resultCopy = player.Results[rp - 1]; // Result coding is Result; Op.; Clr; Brd; Logical ops. 1 & 2; Game pnts"
		resultCopy = resultCopy.split(';'); // we're going to want these individually from here on out
		resultCopy.push(player['Pair number']); // save the player's pairing number here for later use
		gameResults.push(resultCopy);  
	});
	// sort byes to the end and otherwise in board number 
	gameResults.sort(function(a,b) {
		const aBoard = a[3];
		const bBoard = b[3];
		if ((aBoard == 0) && (bBoard == 0)) {
			// both byes, so sort by, I dunno, player pairing number
			const aPairNo = a[6];
			const bPairNo = b[6];
			return aPairNo - bPairNo; // lower pairing numbers to the front
		}
		if (aBoard == 0) {
			// only a bye for one of them, so sort it to the end
			return 1; // i.e., a (bye) second
		}
		if (bBoard == 0) {
			// only a bye for one of them, so sort it to the end
			return -1; // i.e., a first then b (bye)
		}
		return aBoard - bBoard; // lower board numbers to the front
	});

	const pairingsDiv = document.getElementById('pairingsDiv');
	//
	//	The table of games consists of an outer table with the header and an
	//	inner table with the game list, which is embedded in a scrolling div.
	//
	let pTable = `<table id="GLOuter" style='width: 100%;'>
		<thead>
			<tr>
				<th class="Board">Board</th>
				<th class="Score">Scr</th>
				<th class="Name">White</th>
				<th class="Score">Scr</th>
				<th class="Name">Black</th>
			</tr>
		</thead>
		<tbody>`;

	let doneBoards = new Set();
	gameResults.forEach(gameResult => {
		// Result coding is Result; Op.; Clr; Brd; Logical ops. 1 & 2; Game pnts; Player"
		let board = gameResult[3];
		let leftResult, leftName, leftPoints, rightResult, rightName, rightPoints;
		let duplicate = false;

		if (board == 0) {
			// bye setup
			board = '';
			leftResult = resultToScore(gameResult[0], false);
			leftName = section.Players[gameResult[7] - 1].Name;
			rightResult = '';
			rightName = 'Bye';
		} else {
			// see if we already did this board
			duplicate = doneBoards.has(board);
			if (!duplicate) {
				// nope, process
				doneBoards.add(board);
				if (gameResult[2] === 'W') {
					leftResult = resultToScore(gameResult[0], false);
					leftName = section.Players[gameResult[7] - 1].Name;
					leftPoints = vTable.getPlayerPoints(section.Players[gameResult[7] - 1], rp);			
					rightResult = resultToScore(gameResult[0], true);
					rightName = section.Players[gameResult[1] - 1].Name;
					rightPoints = vTable.getPlayerPoints(section.Players[gameResult[1] - 1], rp);			
				} else {
					rightResult = resultToScore(gameResult[0], false);
					rightName = section.Players[gameResult[7] - 1].Name;			
					rightPoints = vTable.getPlayerPoints(section.Players[gameResult[7] - 1], rp);			
					leftResult = resultToScore(gameResult[0], true);
					leftName = section.Players[gameResult[1] - 1].Name;
					leftPoints = vTable.getPlayerPoints(section.Players[gameResult[1] - 1], rp);			
				}
			} else {
				// yup, already did this board
			}
		}

		if (leftPoints !== undefined) {
			leftPoints = '(' + leftPoints.toFixed(1) + ')';
		} else {
			leftPoints = '';
		}
		if (rightPoints !== undefined) {
			rightPoints = '(' + rightPoints.toFixed(1) + ')';
		} else {
			rightPoints = '';
		}
		
		if (!duplicate) {
			resultLine = `<tr>
				<td class="Board">${board}</td>
				<td class="Score">${leftResult} ${leftPoints}</td>
				<td class="Name">${leftName}</td>
				<td class="Score">${rightResult} ${rightPoints}</td>
				<td class="Name">${rightName}</td>
			</tr>`;
			pTable = `${pTable}${resultLine}`;
		}
	});

	pairingsDiv.innerHTML = `${pTable}
			</tbody>
		</table>`;
	pairingsDiv.style.display = 'block';
}

function resultToScore(result, flip = false) 
{
	switch (result) {
		case '-': // deliberate fallthrough
		case 'F': 
			if (flip) {
				return 1.0; // opposite of a loss is a win, opposite of a forfeit loss is a forfeit win
			}
			return 0.0;
			break;
		case 'Z': 
			if (flip) {
				return 0.0; // assume forfeit draw is vs. forfeit loss.
			}
			return 0.5; 
		case '=':  // deliberate fallthrough
		case 'H':
			return 0.5; // these two results don't flip
			break;
		case '+': // deliberate fallthrough
		case 'X': 
			if (flip) {
				return 0.0; // opposite of a win is a loss, opposite of a forfeit win is a forfeit loss.
			}
			return 1.0;
			break;
		case 'B': 
			return 1.0; // this result doesn't flip since there's no opponent.
			break; 
		case '~': // unplayed game
		case 'U': 
			return 0.0; // this result doesn't flip since there's no game here.
			break;
		default:
			console.log('UNKNOWN RESULT: ' + result);
			return 0.0;
			break;
	}
}

function parsePTOZDate(dateString)
{
	const splitSlash = dateString.split(/\/|-/);
	const splitDash = dateString.split('-');
	var startDate;
	var endDate;
	if (splitSlash.length === 6) {
		// we have a start date and an end date
		startDate = dateParse(splitSlash, 0);
		endDate = dateParse(splitSlash, 3);
	} else if (splitSlash.length === 3) {
		// we have one date
		startDate = dateParse(splitSlash, 0);
		endDate = startDate;
	} else if (splitDash.length === 6) {
		// we have a start date and an end date
		startDate = dateParse(splitDash, 0);
		endDate = dateParse(splitDash, 4);
	} else if (splitDash.length === 3) {
		// we have one date
		startDate = dateParse(splitDash, 0);
		endDate = startDate;
	}
	let ptozDate = endDate;
	if (ptozDate === undefined) {
		// yolo it
		ptozDate = new Date(Date.parse(dateString) + 1000*60*60*12);
	}
	return ptozDate;
}

function dateParse(parts, i) 
{
	let year, month, day;
	if (parts[i].length === 4) {
		year = Number.parseInt(parts[i]);
		i++;
		if (parts[i].length == 2) {
			month = Number.parseInt(parts[i]);
		}
		i++;
		if (parts[i].length === 2) {
			day = Number.parseInt(parts[i]);
		}
	} else if (parts[i].length === 2) {
		month = Number.parseInt(parts[i]);
		i++;
		if (parts[i].length == 2) {
			day = Number.parseInt(parts[i]);
		}
		i++;
		if (parts[i].length === 4) {
			year = Number.parseInt(parts[i]);
		}
	}
	if ((year !== undefined) && (month !== undefined) && (day !== undefined)) {
		// new Date(year, monthIndex, day, hours)
		return new Date(year, (month - 1), day, 12); 
	} else {
		return undefined;
	}
}

function loadTournaments(ptozFile, swissSysFile)
{
	//	getBinaryContent takes (path,callback) where callback is function(err,data)
	//
	JSZipUtils.getBinaryContent(ptozFile, function(err,data) {
		if (err) throw err;
		JSZip.loadAsync(data)
		.then(function(zip) {
			//
			//	async returns a Promise of the content on the asked type.
			//	JSON isn't an option so we need to get a string and translate it
			//	to a JSON object using JSON.parse.
			//
			zip.file("Json").async("string")
			.then(function(jsonText) {		
				ptoz = JSON.parse(jsonText);
				fetch(swissSysFile)
					.then((res) => res.text())
					.then((jsonText) => {
						sjson = JSON.parse(jsonText);

						// figure out which is more recent.  This is a bit of a crapshoot as it depends on the date field, which is kind of arbitrary especially for the PTOZ version.
						// if there are two dates in the ptoz separated by a - or space, try to take the last one as the ending date
						const origPtozDate = ptoz.dates;
						console.log('ptoz raw date string: ' + origPtozDate);
						ptoz.dates = ptoz.dates.trim().replace(/[^0-9\/-]/g, '');
						console.log('ptoz cooked date string: ' + origPtozDate);

						// detect and process 10/15/2024, 10-15-2024, 2024-10-15, 2024/10/15
						// but also detect and process all of those 2024-10-15-2025-04-22
						const ptozDate = parsePTOZDate(ptoz.dates);
						console.log('ptoz date parsed: ' + ptozDate);
						let ssDate = new Date(Date.parse(sjson.Overview['Ending date']) + 1000*60*60*12);

						// show whichever has the theoretical later ending date
 						if (ptozDate > ssDate) {
							ptoz.vTable = getVTablePTOZ();
							TestShow(ptoz); 
						} else {
							sjson.vTable = getVTableSwissSys();
							TestShow(sjson);
						} 
					})
					.catch((e) => console.error(e));
			})
			.catch((e) => console.error(e));
		}).catch((e) => console.error(e));
	});
}

function getVTablePTOZ()
{
	let vTable = {};
	vTable.calcCumulativePlayerScores = function(player) {
		let playerScores = [];
		let score = 0.0;
		let byeAdjustment = 0.0;

		player.tnmt.games.forEach(gameNum => {
			if ((gameNum !== -1) && (gameNum !== null)) {
				const game = tourney.games[gameNum];
				const result = game.result;
				if (game.p1 === player.tnmt.playerNo) {
					if (result == 0) {
						score = score + 0.5;
						if (game.p2 === -1) {
							byeAdjustment = byeAdjustment + 0.5; // unplayed game
						}
					} else if (result == +1 || result == +3) {
						score = score + 1.0;
						if (game.p2 === -1) {
							byeAdjustment = byeAdjustment + 1.0; // unplayed game
						}
					} else if (result == -1) {
						score = score + 0.0;
					} else if (result == +2) {
						// forfeit win 
						score = score + 1.0;
						byeAdjustment = byeAdjustment + 1.0; // unplayed game
					} else if (result == -2 || result == -98) {
						// forfeit loss
						score = score + 0.0;
					} else if (result === 99) {
						// not played yet
						score = score + 0.0;
					} else {
						console.log('UNKNOWN RESULT ' + result);
					}
				} else {
					if (result == 0) {
						score = score + 0.5;
						if (game.p1 === -1) {
							byeAdjustment = byeAdjustment + 0.5; // unplayed game
						}
					} else if (result == -1) {
						score = score + 1.0;
						if (game.p1 === -1) {
							byeAdjustment = byeAdjustment + 1.0; // unplayed game
						}
					} else if (result == +1) {
						score = score + 0.0;
					} else if (result == -2) {
						// forfeit win 
						score = score + 1.0;
						byeAdjustment = byeAdjustment + 1.0; // unplayed game
					} else if (result == +2 || result == -98) {
						// forfeit loss
						score = score + 0.0;
					} else if (result === 99) {
						// not played yet
						score = score + 0.0;
					} else {
						console.log('UNKNOWN RESULT ' + result);
					}
				}
			} else {
				// unplayed game, zero score 
			}
			playerScores.push(score);
		});
		playerScores.push(0 - byeAdjustment);

		return playerScores;
	}
	vTable.calcScoreColorStringPlayerNumByeTypeIsByeOppRating = function(j, section, sectionPlayers, player, playerNumAlgo, colorStringAlgo) {
		// j is just a zero-based round number, so round = j + 1;
		let gameNum, colorString, playerNum, byeType, isBye, oppRating;
		let score = 0.0;
		let playedGame = true;
		if (j >= player.tnmt.games.length) {
			gameNum = -1;
		} else {
			gameNum = player.tnmt.games[j];
		}
		if ((gameNum !== -1) && (gameNum !== null)) {
			const game = tourney.games[player.tnmt.games[j]];
			let opponentNum, result, color, colorNum;
			console.log(JSON.stringify(game));
			if (game.p1 === player.tnmt.playerNo) {
				opponentNum = game.p2;
				result = GameResultP1(game.result);
				colorNum = game.color1;
			} else {
				opponentNum = game.p1;
				result = GameResultP2(game.result);
				colorNum = game.color2;
			}
			if (colorNum === 1) {
				color = 'W';
			} else {
				color = 'B';
			}
			switch (result) {
				case '0.0F': 
					playedGame = false;
				case '0.0': // deliberate fallthrough
					score += 0.0;
					byeType = 'U';
					break;
				case '0.5':
					score += 0.5;
					byeType = 'H';
					break;
				case '1.0F': 
					playedGame = false;
				case '1.0': // deliberate fallthrough
					score += 1.0;
					byeType = 'B';
					break;
				case '': // unplayed game
				case '   ': // deliberate fallthrough
					playedGame = false;
					score += 0.0; 
					byeType = 'U';
					break;
				default:
					playedGame = false;
					console.log('UNKNOWN RESULT: ' + result);
					break;
			}
			colorString = colorStringAlgo(color, result);
			if (opponentNum !== -1) {
				opponent = tourney.players[opponentNum];
				playerNum = playerNumAlgo(opponent, sectionPlayers);
				if (playedGame) {
					oppRating = vTable.getPlayerRating(opponent, section);
					if (oppRating === 'Unr') {
						oppRating = Number.NaN;
					}
				}
			} else {
				isBye = true;
			}
		} else {
			score += 0.0;
			isBye = true;
			byeType = 'U';
		}

		return [score, colorString, playerNum, byeType, isBye, oppRating];
	}
	vTable.calcMMAdjustedScore = function(player) {
		// 	These scores are adjusted for unplayed games, which count a half point each, regardless of whether they were byes, forfeits, or simply rounds not played after an opponent withdrew.
		let score = 0.0;
		player.tnmt.games.forEach(gameNum => {
			if ((gameNum !== -1) && (gameNum !== null)) {
				const game = tourney.games[gameNum];
				const result = game.result;
				if (game.p1 === player.tnmt.playerNo) {
					if (result == 0) {
						score = score + 0.5;
					} else if (result == +1 || result == +3) {
						score = score + 1.0;
					} else if (result == -1) {
						score = score + 0.0;
					} else if (result == +2) {
						score = score + 0.5; // forfeit
					} else if (result == -2 || result == -98) {
						score = score + 0.5; // forfeit
					} else if (result == 99) {
						score = score + 0.0; // not played yet
					} else {
						console.log('UNKNOWN RESULT ' + result);
					}
				} else {
					if (result == 0) {
						score = score + 0.5;
					} else if (result == -1) {
						score = score + 1.0;
					} else if (result == +1) {
						score = score + 0.0;
					} else if (result == -2) {
						score = score + 0.5; // forfeit
					} else if (result == +2 || result == -98) {
						score = score + 0.5; // forfeit
					} else if (result == 99) {
						score = score + 0.0; // not played yet
					} else {
						console.log('UNKNOWN RESULT ' + result);
					}
				}
			} else {
				score = score + 0.5; 
			}
		});

		return score;
	}	
	vTable.getDate = function(ptoz) {
		return ptoz.dates;
	}
	vTable.getOpponents = function(player) {
		let opponents = [];
		player.tnmt.games.forEach(gameNum => {
			if ((gameNum !== -1) && (gameNum !== null)) {
				const game = tourney.games[gameNum];
				// figure out the opponent
				let opponentNum;
				if (game.p1 === player.tnmt.playerNo) {
					opponentNum = game.p2;
				} else {
					opponentNum = game.p1;
				}
				if (opponentNum !== -1) {
					opponents.push(tourney.players[opponentNum]);
				} else {
					opponents.push(null); // unplayed game, counts as opponent with a 0 score.  This is implicitly assuming that these guys are eligible to be dropped later
				}
			} else {
				opponents.push(null); // unplayed game, counts as opponent with a 0 score.  This is implicitly assuming that these guys are eligible to be dropped later
			}
		});
		return opponents;
	}
	vTable.getPlayerId = function(player) {
		if (player.base.id !== undefined) {
			return player.base.id;
		} else {
			return '';
		}
	}
	vTable.getPlayerName = function(player) {
		return player.base.name;
	}
	vTable.getPlayerPairNo = function(player) {
		return player.tnmt.pairno;
	}
	vTable.getPlayerPoints = function(player, maxRounds = Number.MAX_SAFE_INTEGER) {
		if (player === undefined) {
			return undefined;
		}
		if (player.tnmt === undefined) {
			return undefined;
		}

		let score = 0.0;
		
		for (const [i, gameNum] of player.tnmt.games.entries()) {
			if ((i < maxRounds) && (gameNum !== -1) && (gameNum !== null)) {
				const game = tourney.games[gameNum];
				const result = game.result;
				// "result":{"type":"integer","description":"Result. +1=1st player wins, -1=2nd player wins, 0=draw,+2=1st player wins by forfeit, -2=2nd player wins by forfeit, 98=double forfeit, 99=No result yet"},
				if (game.p1 === player.tnmt.playerNo) {
					if (result == 0) {
						score = score + 0.5;
					} else if (result == +1 || result == +3) {
						score = score + 1.0;
					} else if (result == -1) {
						score = score + 0.0;
					} else if (result == +2) {
						score = score + 1.0; // forfeit
					} else if (result == -2 || result == -98) {
						score = score + 0.0; // forfeit loss or double forfeit
					} else if (result == 99) {
						score = score + 0.0; // not played yet
					} else {
						console.log('UNKNOWN RESULT ' + result);
					}
				} else {
					if (result == 0) {
						score = score + 0.5;
					} else if (result == -1) {
						score = score + 1.0;
					} else if (result == +1) {
						score = score + 0.0;
					} else if (result == -2) {
						score = score + 1.0; // forfeit
					} else if (result == +2 || result == -98) {
						score = score + 0.0; // forfeit loss or double forfeit
					} else if (result == 99) {
						score = score + 0.0; // not played yet
					} else {
						console.log('UNKNOWN RESULT ' + result);
					}
				}
			}
		}

		return score;		
	}
	vTable.getPlayerRating = function(player, section) {
		let tc = section.TC;
		if (tc === undefined) {
			tc = "G/90;d5";
		}
		let tcParts = section.TC.split(';');
		tcParts[0] = tcParts[0].replace(/[^\d]/g, '');
		tcParts[1] = tcParts[1].replace(/[^\d]/g, '');
		tcParts[0] = Number.parseInt(tcParts[0]);
		tcParts[1] = Number.parseInt(tcParts[1]);
		if ((tcParts[0] + tcParts[1]) < 30) {
			if (player.base.localrate !== undefined) {
				return player.base.localrate;
			} else {
				return 'Unr';
			}
		} else {
			if (player.base.rating !== undefined) {
				return player.base.rating;
			} else {
				return 'Unr';
			}
		}
	}
	vTable.getResultString = function(color, result) {
		/*
		'', '   ' - Paired but not yet played
		W - Win
		L - Loss
		D - Draw
		B - Full Point Bye
		H - Half Point Bye
		F - Forfeit Loss
		X - Forfeit Win
		Z - Forfeit Draw
		U - Not Paired (also Zero Point Bye)
		*/
		switch (result) {
			case '':
			case '   ': // deliberate fallthrough
				return 'A';
			case '0.0': 
				return 'L';
			case '0.0F':
				return 'F'; 
			case '0.5':
				return 'D';
			case '1.0':
				return 'W';
			case '1.0F':
				return 'X';
			default:
				return 'UN';
		}
	}
	vTable.getSections = function(ptoz) {
		return ptoz.sections;
	}
	vTable.getSectionId = function(section) {
		return section.id;
	}
	vTable.getSectionPlayers = function(sectionId) {
		return tourney.players.filter((player) => player.tnmt.sectionID === sectionId);
	}
	vTable.getSectionRoundsPaired = function(section) {
		return section.roundsPaired;
	}
	vTable.getSectionTitle = function(section) {
		return section.title;
	}
	vTable.getTitle = function(ptoz) {
		return ptoz.title;
	}
	vTable.ShowPairings = ShowPairingsPTOZ;
	return vTable;
}

function getVTableSwissSys()
{
	let vTable = {};
	vTable.calcCumulativePlayerScores = function(player) {
		// 	These scores are adjusted for unplayed games, which count zero points each, regardless of whether they were byes, forfeits, or simply rounds not played after an opponent withdrew.
		let playerScores = [];
		let score = 0.0;
		let byeAdjustment = 0.0;

		player.Results.forEach(gameResult => {
			// "-;28;W;116;28;0;0"  "U;0;-;0;0;0;0"
			const items = gameResult.split(';');

			let result = items[0];
			switch (result) {
				case '-':
					score += 0.0;
					playerScores.push(score);
					break;
				case '=':  
					score += 0.5;
					playerScores.push(score);
					break;
				case '+': 
					score += 1.0;
					playerScores.push(score);
					break;
				case 'F': // deliberate fallthrough
				case 'U': 
				case '~': 
					score += 0.0;
					playerScores.push(score);
					break;
				case 'Z': // deliberate fallthrough
				case 'H':
					score += 0.5;
					byeAdjustment += 0.5; // these are unplayed, so they need an adjustment later
					playerScores.push(score);
					break;
				case 'X': 
				case 'B': 
					score += 1.0;
					byeAdjustment += 1.0; // these are unplayed, so they need an adjustment later
					playerScores.push(score);
					break;
				default:
					console.log('UNKNOWN RESULT: ' + result);
					playerScores.push(score);
					break;
			}
		});
		playerScores.push(0 - byeAdjustment);

		return playerScores;
	}
	vTable.calcScoreColorStringPlayerNumByeTypeIsByeOppRating = function(j, section, sectionPlayers, player, playerNumAlgo, colorStringAlgo) {
		// j is just a zero-based round number, so round = j + 1;
		let gameNum, colorString, playerNum, byeType, isBye;
		let score = 0.0;
		let playedGame = true;
		let oppRating;

		const gameResult = player.Results[j]; // "-;28;W;116;28;0;0"  "U;0;-;0;0;0;0"
		const items = gameResult.split(';');

		const opponentNum = items[1];
		const board = items[3];
		if (board == 0) {
			isBye = true;
		}

		let result = items[0];
		switch (result) {
			case 'F': 
			case 'U': 
			case '~':
				playedGame = false;
			case '-': // deliberate fallthrough
				score += 0.0;
				byeType = 'U';
				break;
			case 'Z':
			case 'H':
				playedGame = false;
			case '=':  // deliberate fallthrough
				score += 0.5;
				byeType = 'H';
				break;
			case 'X': 
			case 'B': 
				playedGame = false;
			case '+': // deliberate fallthrough
				score += 1.0;
				byeType = 'B';
				break;
			default:
				playedGame = false;
				console.log('UNKNOWN RESULT: ' + result);
				break;
		}

		let color = items[2];
		colorString = colorStringAlgo(color, result);
		if (!isBye) {
			const opponent = section.Players[opponentNum - 1];
			playerNum = playerNumAlgo(opponent, sectionPlayers);
			if (playedGame) {
				oppRating = vTable.getPlayerRating(opponent, section);
				if (oppRating === 'Unr') {
					oppRating = Number.NaN;
				}
			}
		} 

		return [score, colorString, playerNum, byeType, isBye, oppRating];
	}
	vTable.calcMMAdjustedScore = function(player) {
		// 	These scores are adjusted for unplayed games, which count a half point each, regardless of whether they were byes, forfeits, or simply rounds not played after an opponent withdrew.
		let score = 0.0;

		player.Results.forEach(gameResult => {
			// "-;28;W;116;28;0;0"  "U;0;-;0;0;0;0"
			const items = gameResult.split(';');

			let result = items[0];
			switch (result) {
				case '~': // this game is pending so it's absolutely no result yet.
					score += 0.0;
					break;
				case '-':
					score += 0.0;
					break;
				case '=':  
					score += 0.5;
					break;
				case '+': 
					score += 1.0;
					break;
				case 'F': // deliberate fallthrough
				case 'U': 
				case 'Z':
				case 'H':
				case 'X': 
				case 'B': 
					// all of these are unplayed games, so they count 0.5
					score += 0.5;
					break;
				default:
					console.log('UNKNOWN RESULT: ' + result);
					break;
			}
		});

		return score;
	}	
	vTable.getDate = function(sjson) {
		return `${sjson.Overview['Starting date']}-${sjson.Overview['Ending date']}`;
	}
	vTable.getOpponents = function(player) {
		// first figure out what section this player is in.  We basically know this players' index so that shouldn't take long.
		let section;
		let playerPairNo = player['Pair number'];
		let playerIndex = playerPairNo - 1;
		sjson.Sections.forEach(sectionToTest => {
			if (sectionToTest.Players[playerIndex] === player) {
				section = sectionToTest;
			}
		});

		let opponents = [];
		player.Results.forEach(gameResult => {
			const items = gameResult.split(';');
			const opponentNum = items[1];
			const board = items[3];
			if (board == 0) {
				opponents.push(null); // unplayed game, counts as opponent with a 0 score.  This is implicitly assuming that these guys are eligible to be dropped later
			} else {
				opponents.push(section.Players[opponentNum - 1]);
			}
		});
		return opponents;
	}
	vTable.getPlayerId = function(player) {
		if (player.ID !== undefined) {
			return player.ID;
		} else {
			return '';
		}
	}
	vTable.getPlayerName = function(player) {
		return player.Name;
	}
	vTable.getPlayerPairNo = function(player) {
		return player['Pair number'];
	}
	vTable.getPlayerPoints = function(player, maxRounds = Number.MAX_SAFE_INTEGER) {
		let score = 0.0;

		for (const [i, gameResult] of player.Results.entries()) {
			if (i < maxRounds) {
				// "-;28;W;116;28;0;0"  "U;0;-;0;0;0;0"
				const items = gameResult.split(';');

				let result = items[0];
				switch (result) {
					case '-': // deliberate fallthrough
					case 'F': 
					case 'U': 
					case '~':
						score += 0.0;
						break;
					case '=': // deliberate fallthrough
					case 'Z':
					case 'H':
						score += 0.5;
						break;
					case '+': // deliberate fallthrough
					case 'X': 
					case 'B': 
						score += 1.0;
						break;
					default:
						console.log('UNKNOWN RESULT: ' + result);
						break;
				}
			}
		}

		return score;
	}
	vTable.getPlayerRating = function(player, section) {
		if (player.Rating !== undefined) {
			return player.Rating;
		} else {
			return 'Unr';
		}
	}
	vTable.getResultString = function(color, result) {
		/*
		W - Win
		L - Loss
		D - Draw
		B - Full Point Bye
		H - Half Point Bye
		F - Forfeit Loss
		X - Forfeit Win
		Z - Forfeit Draw
		U - Not Paired (also Zero Point Bye)
		*/
		switch (result) {	
			case '~':
				return 'A'; // not played yet	
			case '-': 
				return 'L';
			case '=':
				return 'D';
			case '+':
				return 'W';
			case 'F': // deliberate fallthrough - all of these are already codes
			case 'U': 
			case 'Z':
			case 'H':
			case 'X': 
			case 'B': 
			case 'A':
				return result;
			default:
				console.log('UNKNOWN RESULT: ' + result);
				return 'UN';
		}		
	}
	vTable.getSections = function(sjson) {
		return sjson.Sections;
	}
	vTable.getSectionId = function(section) {
		const index = tourney.Sections.findIndex((sectionToTest) => sectionToTest == section);

		return index;
	}
	vTable.getSectionPlayers = function(sectionId) {
		const sectionPlayers = tourney.Sections[sectionId].Players;
		return Array.from(sectionPlayers);
	}
	vTable.getSectionRoundsPaired = function(section) {
		return section['Rounds paired'];
	}
	vTable.getSectionTitle = function(section) {
		return section['Section name'];
	}
	vTable.getTitle = function(sjson) {
		return sjson.Overview['Tournament title'];
	}
	vTable.ShowPairings = ShowPairingsSJSON;
	return vTable;
}

</script>
</head>
<body>
	<div id="topDiv" style="height: 20%; overflow:auto">
		<p id="tName"></p>
		<p id="tDate"></p>
	</div>

	<div id="controlsDiv">
	</div>

	<div id="pairingsDiv" style="height: 60%; width: 100%; display:none">
	</div>

	<div id="wallChartDiv" style="height: 60%; width: 100%; display:none">
	</div>

	<script>
		// see if we got tournament parameters or not
		let ptozFileName = 'tournament.ptoz';
		let sjsonFileName = 'tournament.sjson';
		const get = window.location.search;
		const i = get.indexOf('?');
		if (i !== -1) {
			const params = new Map();
			const pairs = get.substring(i + 1).split('&');
			pairs.forEach(pair => { 
				const nameVal = pair.split('=');
				params.set(nameVal[0], nameVal[1]);
			});
			pfn = params.get('ptoz');
			if (pfn !== undefined) {
				ptozFileName = pfn;
			}
			sfn = params.get('sjson');
			if (sfn !== undefined) {
				sjsonFileName = sfn;
			}
		}
	loadTournaments(ptozFileName, sjsonFileName);
	</script>
</body>
</html>
