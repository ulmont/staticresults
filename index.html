<!DOCTYPE html>
<html>
<head>
	<style>
		#controlsDiv {
			height: 40px;
			background-color: #222266"
		}
		#tName {
			font-size: 1.5em; 
			font-weight: bold;
			margin: 0;
		}
		#tDate {
			margin: 0;
		}
		table tr:nth-child(even) {
			background-color: #00bbFF;
		}
		/*
		** The drop downs are arranged as a table with no borders
		*/
		table.ControlOuter th,
		table.ControlOuter td {
			padding: 5px;
		}
		tbody div {
			overflow-y: auto;
			scrollbar-gutter: stable;
			height: auto;
		}
		th.Board, td.Board {
			width: auto;
			padding: 3px;
		}
		th.Board, th.Number {
			text-align: left;
		}
		td.Board {
			text-align: right;
		}
		th.Score, td.Score {
			width: auto;
			padding: 3px;
		}
		th.Name, td.Name {
			width: auto;
			padding: 3px;
			text-align: left;
		}
	</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip-utils/0.1.0/jszip-utils.min.js"></script>
<script type="text/javascript">

function TestShow(ptoz)
{
	SetupControls(ptoz);
	SetupGlobals(ptoz);
}

function SetupGlobals(ptoz) 
{
	// update the title etc.
	document.getElementById('tName').innerText = ptoz.title;
	document.getElementById('tDate').innerText = ptoz.dates;
}

function SetupControls(ptoz)
{
	//
	//	Fish the arrays of the main objects out of the JSON PTOZ into globals
	//
	sections = ptoz.sections;
	players = ptoz.players;
	games = ptoz.games;

	const controlsDiv = document.getElementById('controlsDiv');
	controlsDiv.innerHTML = "<table class='ControlOuter'><tr><td id='chartsBox'></td><td id='sectionBox'></td><td id='roundsBox'></td></tr></table>";

	SetupCharts();
}

function SetupCharts()
{
	const chartsElement = document.getElementById('chartsBox');
	let chartsBox;
	chartsBox = `Charts:<select id='chartsDD' onchange='onChartsChange()'>
		<option value="Pairings">Pairings</option>
		<option value="Wall Chart">Wall Chart</option>
		<option value="Standings">Standings</option>
	</select>`;

	chartsElement.innerHTML = chartsBox;
	document.getElementById("chartsDD").selectedIndex = 0;

	onChartsChange();
}

function onChartsChange()
{
	// just always setup the Sections and let the Section switch figure out what to display after that
	SetupSections();
}

function onSectionChange()
{
	let section = getSection();
	SetupRounds(section.roundsPaired);
}

function SetupSections()
{
	const sectionsElement = document.getElementById('sectionBox');
	let sectionBox;
	if (sections.length === 1) {
		// special case the single-section (Open, typically) event
		sectionBox = `Section: ${sections[0].title}`;
		sectionsElement.innerHTML = sectionBox;
	} else {
		sectionBox = "Section:<select id='sectionDD' onchange='onSectionChange()'>";
		for (let i = 0; i < sections.length; i++) {
			//
			//	Skip any sections which have no paired rounds
			//
			if (sections[i].roundsPaired == 0)
				continue;
			const sectionValue = `<option value=${i}>${sections[i].title}</option>`;
			sectionBox = `${sectionBox}${sectionValue}`;
		}
		sectionBox = `${sectionBox}
		</select>`;
		//
		//	Pick the first section in the list as the default and force
		//	the section change to update the rounds box
		//
		sectionsElement.innerHTML = sectionBox;
		document.getElementById("sectionDD").selectedIndex = 0;
	}

	onSectionChange();
}

function getSection() 
{
	if (sections.length === 1) {
		return sections[0];
	} else {
		let sectionDD = document.getElementById("sectionDD");
		let sectionsValue = sectionDD.options[sectionDD.selectedIndex].value;
		let section = sections[sectionsValue];
		return section;
	}
}

function onSectionChange()
{
	const section = getSection();

	let chartsDD = document.getElementById("chartsDD");
	let chartsValue = chartsDD.options[chartsDD.selectedIndex].value;
	switch (chartsValue) {
		case 'Pairings':
			SetupRounds(section.roundsPaired);
			break;
		case 'Wall Chart':
			SetupWallChart(section, sortPlayersByPairNo, getPlayerPairingNumber, getColorString);
			break;
		case 'Standings':
			SetupWallChart(section, sortPlayersByScoreTiebreaks, getPlayerIndex, getResultString);
			break;
		default:
			SetupRounds(section.roundsPaired);
			break;
	}
}

function sortPlayersByPairNo(a, b)
{
	if (a.tnmt.pairno < b.tnmt.pairno) {
		return -1; // lower pairing number sorts first
	}

	if (a.tnmt.pairno > b.tnmt.pairno) {
		return 1; // higher pairing number sorts last
	}

	return 0; // shouldn't happen for pairing numbers
}

function sortPlayersByScoreTiebreaks(a, b)
{
	if (a.tnmt.pts > b.tnmt.pts) {
		return -1; // higher score sorts first
	}

	if (a.tnmt.pts < b.tnmt.pts) {
		return 1; // lower score sorts last
	}

	console.log('Score: ' + a.tnmt.pts + ' is equal for ' + a.base.name + ' and ' + b.base.name + ' moving to Modified Median');

	/* 34E
	Unless a different method has been posted or announced before the start of the first round, players will expect the following sequence of tiebreak systems to be employed as the first four tiebreakers. 
	1. Modified Median
	2. Solkoff
	3. Cumulative
	4. Cumulative of Opposition
	*/

	const aMM = calcModifiedMedian(a);
	const bMM = calcModifiedMedian(b);
	// console.log('Modified Median: ' + aMM + ' for ' + a.base.name + ' vs ' + bMM + ' for ' + b.base.name);
	if (aMM > bMM) {
		return -1; // higher sorts first
	}

	if (aMM < bMM) {
		return 1; // lower sorts last
	}

	console.log('Modified Median: ' + aMM + ' is equal for ' + a.base.name + ' and ' + b.base.name + ' moving to Solkoff');
	const aS = calcSolkoff(a);
	const bS = calcSolkoff(b);
	console.log('Solkoff: ' + aS + ' for ' + a.base.name + ' vs ' + bS + ' for ' + b.base.name);
	if (aS > bS) {
		return -1; // higher sorts first
	}

	if (aS < bS) {
		return 1; // lower sorts last
	}

	console.log('Solkoff: ' + aS + ' is equal for ' + a.base.name + ' and ' + b.base.name + ' moving to Cumulative');
	// Cumulative

	// Cumulative of Opposition

	return 0;
}

function calcSolkoff(player) 
{

	/*34E2. Solkoff.
	The Solkoff system is the same as the Median system (34E1) except that no opponents’ scores are discarded.
	The Median system, also known as the Harkness system for inventor Kenneth Harkness, evaluates the strength of a player’s opposition by summing the final scores of his or her opponents and then discarding the highest and lowest of these scores.
	...
	These scores are adjusted for unplayed games, which count a half point each, regardless of whether they were byes, forfeits, or simply rounds not played after an opponent withdrew. So an opponent who won the first two games, lost the third, withdrew and did not play rounds four or five would have an adjusted score of 3 points (1+1+0+0.5+0.5 = 3). These adjusted scores are used only to calculate the opponent’s tiebreaks. The player’s own score is not changed.

	If the player involved in the tie has any unplayed games, they count as opponents with adjusted scores of 0.
	*/
	let opponentScores = calcOpponentScores(player);
	// console.log('opponents scores: ' + opponentScores);

	// The Solkoff system is the same as the Median system (34E1) except that no opponents’ scores are discarded.
	let s = 0.0;
	opponentScores.forEach(score => {
		s = s + score;
	});

	return s;
}

function calcModifiedMedian(player) 
{
	const section = getSection();

	/*34E1. Modified Median
	The Median system, also known as the Harkness system for inventor Kenneth Harkness, evaluates the strength of a player’s opposition by summing the final scores of his or her opponents and then discarding the highest and lowest of these scores.

	In the Modified Median system, players who tie with even scores (an even score is equal to exactly one half of the maximum possible score), have the highest- and lowest-scoring opponents’ scores excluded. The system is modified for players with non-even scores to disregard only the least significant opponents’ scores: the lowest-scoring opponent’s score is discarded for tied players with plus scores and the highest-scoring for tied players with minus scores.

	For tournaments of nine or more rounds, the top two and bottom two scores are discarded for even-score ties, the bottom two scores for plus-score ties, and the top two scores for minus-score ties.

	These scores are adjusted for unplayed games, which count a half point each, regardless of whether they were byes, forfeits, or simply rounds not played after an opponent withdrew. So an opponent who won the first two games, lost the third, withdrew and did not play rounds four or five would have an adjusted score of 3 points (1+1+0+0.5+0.5 = 3). These adjusted scores are used only to calculate the opponent’s tiebreaks. The player’s own score is not changed.

	If the player involved in the tie has any unplayed games, they count as opponents with adjusted scores of 0.*/

	let opponentScores = calcOpponentScores(player);
	// console.log('opponents scores pre-slice: ' + opponentScores);

	const even = section.roundsPaired / 2.0; // (an even score is equal to exactly one half of the maximum possible score)
	if (player.tnmt.pts === even) {
		console.log(player.tnmt.pts + ' in ' + section.roundsPaired + ' is an even score');
		// players who tie with even scores (an even score is equal to exactly one half of the maximum possible score), have the highest- and lowest-scoring opponents’ scores excluded.
		// but don't bother after rounds 1-2 or if somehow we don't have 3 scores listed
		if ((section.roundsPaired > 2) && (opponentScores.length > 2)) {
			opponentScores = opponentScores.slice(1, -1);
		}
		// For tournaments of nine or more rounds, the top two and bottom two scores are discarded for even-score ties
		// but don't bother if somehow we don't still have 3 scores listed.
		if ((section.roundsPaired > 8) && (opponentScores.length > 2)) {
			opponentScores = opponentScores.slice(1, -1);
		}
	} else if (player.tnmt.pts > even) {
		console.log(player.tnmt.pts + ' in ' + section.roundsPaired + ' is a plus score');
		// the lowest-scoring opponent’s score is discarded for tied players with plus scores
		// but don't bother after rounds 1-2 or if somehow we don't have 3 scores listed
		if ((section.roundsPaired > 2) && (opponentScores.length > 2)) {
			opponentScores.shift();
		}
		// the bottom two scores for plus-score ties
		// but don't bother if somehow we don't still have 3 scores listed.
		if ((section.roundsPaired > 8) && (opponentScores.length > 2)) {
			opponentScores.shift();
		}
	} else {
		console.log(player.tnmt.pts + ' in ' + section.roundsPaired + ' is a minus score');
		// the highest-scoring for tied players with minus scores
		// but don't bother after rounds 1-2 or if somehow we don't have 3 scores listed
		if ((section.roundsPaired > 2) && (opponentScores.length > 2)) {
			opponentScores.pop();
		}
		// the top two scores for minus-score ties.
		// but don't bother if somehow we don't still have 3 scores listed.
		if ((section.roundsPaired > 8) && (opponentScores.length > 2)) {
			opponentScores.pop();
		}
	}

	// console.log('opponents scores post-slice: ' + opponentScores);
	let mm = 0.0;
	opponentScores.forEach(score => {
		mm = mm + score;
	});

	return mm;
}

function calcMMAdjustedScore(player)
{
	// 	These scores are adjusted for unplayed games, which count a half point each, regardless of whether they were byes, forfeits, or simply rounds not played after an opponent withdrew.
	let score = 0.0;
	player.tnmt.games.forEach(gameNum => {
		if (gameNum !== -1) {
			const game = games[gameNum];
			const result = game.result;
			if (game.p1 === player.tnmt.playerNo) {
				if (result == 0) {
					score = score + 0.5;
				} else if (result == +1 || result == +3) {
					score = score + 1.0;
				} else if (result == -1) {
					score = score + 0.0;
				} else if (result == +2) {
					score = score + 0.5; // forfeit
				} else if (result == -2 || result == -98) {
					score = score + 0.5; // forfeit
				} else {
					console.log('UNKNOWN RESULT ' + result);
				}
			} else {
				if (result == 0) {
					score = score + 0.5;
				} else if (result == -1) {
					score = score + 1.0;
				} else if (result == +1) {
					score = score + 0.0;
				} else if (result == -2) {
					score = score + 0.5; // forfeit
				} else if (result == +2 || result == -98) {
					score = score + 0.5; // forfeit
				} else {
					console.log('UNKNOWN RESULT ' + result);
				}
			}
		} else {
			score = score + 0.5; 
		}
	});

	return score;
}

function calcOpponentScores(player)
{
	let opponentScores = [];
	player.tnmt.games.forEach(gameNum => {
		if (gameNum !== -1) {
			const game = games[gameNum];
			// figure out the opponent
			let opponentNum;
			if (game.p1 === player.tnmt.playerNo) {
				opponentNum = game.p2;
			} else {
				opponentNum = game.p1;
			}
			if (opponentNum !== -1) {
				const oppScore = calcMMAdjustedScore(players[opponentNum]);
				opponentScores.push(oppScore);
			} else {
				opponentScores.push(0); // unplayed game, counts as opponent with a 0 score.  This is implicitly assuming that these guys are eligible to be dropped later
			}
		} else {
			opponentScores.push(0); // unplayed game, counts as opponent with a 0 score.  This is implicitly assuming that these guys are eligible to be dropped later
		}
	});
	// sort scores low to high
	opponentScores.sort((a, b) => {
		return a - b;
	});
	// console.log('opponents scores pre-slice: ' + opponentScores);

	return opponentScores;
}

function getPlayerPairingNumber(player, sectionPlayers) 
{
	return player.tnmt.pairno;
}

function getPlayerIndex(player, sectionPlayers)
{
	const index = sectionPlayers.findIndex((element) => {
		return (element.tnmt.pairno === player.tnmt.pairno);
	});
	
	return (index + 1);
}

function getColorString(color, result)
{
	return color;
}

function getResultString(color, result)
{
	/*
	W - Win
	L - Loss
	D - Draw
	B - Full Point Bye
	H - Half Point Bye
	F - Forfeit Loss
	X - Forfeit Win
	Z - Forfeit Draw
	U - Not Paired (also Zero Point Bye)
	*/
	switch (result) {
		case '0.0': 
			return 'L';
		case '0.0F':
			return 'F'; 
		case '0.5':
			return 'D';
		case '1.0':
			return 'W';
		case '1.0F':
			return 'X';
		default:
			return 'UN';
	}
}

function SetupWallChart(section, sortAlgo, playerNumAlgo, colorStringAlgo) 
{
	const sectionPlayers = players.filter((player) => player.tnmt.sectionID === section.id);
	const playersToShow = sectionPlayers.sort(sortAlgo);

	// hide the the pairings table
	document.getElementById('pairingsDiv').style.display = 'none';
	// and also hide the round box
	document.getElementById('roundsBox').style.display = 'none'

	/*
		Wall Chart		
	# 	Name			Rds 1...n	Total
		Rating / ID		win / loss
	1	Campbell, Charles Adegboyega	W  19	B  10	W   8	B   2	B   3	4.5
	2198      14497790	1	2	2.5	3.5	4.5
	*/
	const wallChartDiv = document.getElementById('wallChartDiv');
	let pTable = `<table id="GLOuter">
		<thead>
			<tr>
				<th class="Number">#</th>
				<th class="Name">Name<br />Rating / ID</th>`;
	for (let i = 0 ; i < section.roundsPaired ; i++) {
		pTable = `${pTable}
				<th class="Score">Rd ${i+1}</th>`;
	}
	pTable = `${pTable}
			<th class="Score">Total</th>
		</tr>
	</thead>
	<tbody>`;

	for (const [i, player] of playersToShow.entries()) {
		let score = 0.0;
		pTable = `${pTable}
			<tr>
				<td class="Number">${playerNumAlgo(player, sectionPlayers)}</td>
				<td class="Name">${player.base.name}<br />${player.base.rating}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${player.base.id}</td>`;
		for (let j = 0; j < section.roundsPaired; j++) {
			let gameNum;
			let byeType;
			if (j >= player.tnmt.games.length) {
				gameNum = -1;
			} else {
				gameNum = player.tnmt.games[j];
			}
			if (gameNum !== -1) {
				const game = games[gameNum];
				let opponentNum, result, color, colorNum;
				console.log(JSON.stringify(game));
				if (game.p1 === player.tnmt.playerNo) {
					opponentNum = game.p2;
					result = GameResultP1(game.result);
					colorNum = game.color1;
				} else {
					opponentNum = game.p1;
					result = GameResultP2(game.result);
					colorNum = game.color2;
				}
				if (colorNum === 1) {
					color = 'W';
				} else {
					color = 'B';
				}
				switch (result) {
					case '0.0': // deliberate fallthrough
					case '0.0F': 
						score += 0.0;
						byeType = 'U';
						break;
					case '0.5':
						score += 0.5;
						byeType = 'H';
						break;
					case '1.0':
					case '1.0F': // deliberate fallthrough
						score += 1.0;
						byeType = 'B';
						break;
					default:
						console.log('UNKNOWN RESULT: ' + result);
						break;
				}
				const colorString = colorStringAlgo(color, result);
				let opponent;
				if (opponentNum !== -1) {
					opponent = players[opponentNum];
					pTable = `${pTable}
						<td class="Name">${colorString}&nbsp;&nbsp${playerNumAlgo(opponent, sectionPlayers)}<br />${score}</td>`;
				} else {
					pTable = `${pTable}
						<td class="Name">${byeType}<br />${score}</td>`;
				}
			} else {
				pTable = `${pTable}
					<td class="Name">U<br />${score}</td>`;
			}
		}
		pTable = `${pTable}
			<td class="Score">${score}</td>
		</tr>`;
	}
	wallChartDiv.innerHTML = `${pTable}
			</tbody>
		</table>`;
	wallChartDiv.style.display = 'block';
}

function SetupRounds(sectionRounds)
{
	// hide the wall chart table
	document.getElementById('wallChartDiv').style.display = 'none';

	// add the round box
	const roundsElement = document.getElementById('roundsBox');
	let roundsBox = "Round:<select id='roundsDD' onchange='onRoundsChange()'>";
	for (let i = 1; i <= sectionRounds; i++) {
		const roundsValue = `<option value=${i}>${i}`;
		roundsBox += roundsValue;
	}
	console.log(roundsBox);
	roundsElement.innerHTML = roundsBox;
	roundsElement.style.display = 'block'

	//	Select the highest round paired
	//
	document.getElementById("roundsDD").selectedIndex = sectionRounds - 1;
	onRoundsChange();
}

function onRoundsChange()
{
	//
	//	These will be the round number (1,...,roundsPaired) and the section index in the
	//	sections array.
	//
	let roundsDD	= document.getElementById("roundsDD");
	let roundsValue = roundsDD.options[roundsDD.selectedIndex].value;
	let section = getSection();

	ShowPairings(section,roundsValue);
}

function PullGames(sectionID, round)
//
//	Pull the list of game numbers for a section and round
//
{
	gamelist = [];
	for (let i=0 ; i < players.length ; i++) {
		player = players[i];
		//
		// skip if player is not in the section
		//
		if (player["tnmt"]["sectionID"] != sectionID)
			continue;
		//
		//	This is a list of game numbers. -1 means no game for a round
		//
		playerGames = player["tnmt"]["games"];
		//
		// skip if player has no game for this round (either the round is out-of-range or the game number is -1)
		//
		if (round > playerGames.length)
			continue;
		if (playerGames[round-1] == -1 || playerGames[round-1] == null)
			continue;
		console.log(player["base"].name);
		console.log(playerGames[round-1]);
		gamelist.push(playerGames[round-1]);
	}
	console.log(gamelist);
	return gamelist;
}

function GameBoard(game)
//
//	If there is only one player record (for a bye), make the board -1
//
{
	if (game["p1"] == -1 || game["p2"] == -1)
		return -1;
	else
		return game["board"];
}

function GameBoardShow(game)
{
	if (GameBoard(game) == -1)
		return "";
	else
		return GameBoard(game);
}

function GameLeftPlayer(game)
//
//  Get the player number for the player who should be left/white column
//	If the game is a bye, left column should be whichever record is live.
//
{
	if (game["p2"] == -1)
		return game["p1"];
	if (game["p1"] == -1)
		return game["p2"];

	if (game["color1"] == +1)
		return game["p1"];
	else
		return game["p2"];
}

function GameRightPlayer(game)
//
// Get the player number for the player who should be right/black column
//
{
	if (game["p2"] == -1 || game["p1"] == -1)
		return -1;

	if (game["color1"] == +1)
		return game["p2"];
	else
		return game["p1"];
}

function GameResultP1(result)
//
//	Get the string result for player 1
//
{
	if (result == 0)
		return "0.5";
	else if (result == +1 || result == +3)
		return "1.0";
	else if (result == -1)
		return "0.0";
	else if (result == +2)
		return "1.0F";
	else if (result == -2 || result == -98)
		return "0.0F";
	else
		return "   ";
}

function GameResultP2(result) {
	if (result == 0)
		return "0.5";
	else if (result == -1)
		return "1.0";
	else if (result == +1)
		return "0.0";
	else if (result == -2)
		return "1.0F";
	else if (result == +2 || result == -98)
		return "0.0F";
	else
		return "";
}

function GameLeftResult(game)
{
	result = game["result"];
	if (game["color1"] == +1 || game["p2"] == -1)
		return GameResultP1(result);
	else
		return GameResultP2(result);
}

function GameRightResult(game)
{
	if (GameRightPlayer(game) == -1)
		return "   ";
	result = game["result"];
	if (game["color1"] == +1)
		return GameResultP2(result);
	else
		return GameResultP1(result);
}

function PlayerFormat(pnumber)
{
	if (pnumber==-1)
		return "Bye";
	return players[pnumber]["base"]["name"];
}

function ShowPairings(section,rp)
{
//
//	pull array[int] of game numbers and sort by board number, but bubble -1's (byes)
//	to the end
//
	gamelist = PullGames(section["id"],rp);
	gamelist.sort(function(a,b) {
		let aBd = GameBoard(games[a]);
		let bBd = GameBoard(games[b]);
		if (aBd == -1 && bBd == -1)
			return 0;
		if (aBd == -1)
			return +1;
		if (bBd == -1)
			return -1;
		else
			return aBd - bBd;
	});
	const pairingsDiv = document.getElementById('pairingsDiv');
	//
	//	The table of games consists of an outer table with the header and an
	//	inner table with the game list, which is embedded in a scrolling div.
	//
	let pTable = `<table id="GLOuter">
		<thead>
			<tr>
				<th class="Board">Board</th>
				<th class="Score">Scr</th>
				<th class="Name">White</th>
				<th class="Score">Scr</th>
				<th class="Name">Black</th>
			</tr>
		</thead>
		<tbody>`;
	for (let j = 0 ; j < gamelist.length ; j++) {
		//
		//	The above will double up on games with two players, so only show the
		//	first of the two.
		//
		console.log(gamelist[j]);
		if (j > 0 && gamelist[j] == gamelist[j - 1])
			continue;
		boardRec    = gamelist[j];
		game        = games[boardRec];
		board       = GameBoardShow(game);
		leftPlayer  = GameLeftPlayer(game);
		rightPlayer = GameRightPlayer(game);
		leftName    = PlayerFormat(leftPlayer);
		leftResult  = GameLeftResult(game);
		rightName   = PlayerFormat(rightPlayer);
		rightResult = GameRightResult(game);
		resultLine = `<tr>
			<td class="Board">${board}</td>
			<td class="Score">${leftResult}</td>
			<td class="Name">${leftName}</td>
			<td class="Score">${rightResult}</td>
			<td class="Name">${rightName}</td>
		</tr>`;
		pTable += resultLine;
	}
	pairingsDiv.innerHTML = `${pTable}
			</tbody>
		</table>`;
	pairingsDiv.style.display = 'block';
}

function loadZip(file) {
	//
	//	getBinaryContent takes (path,callback) where callback is function(err,data)
	//
	JSZipUtils.getBinaryContent(file,function(err,data) {
		if (err) throw err;
		JSZip.loadAsync(data)
		.then(function(zip) {
			//
			//	async returns a Promise of the content on the asked type.
			//	JSON isn't an option so we need to get a string and translate it
			//	to a JSON object using JSON.parse.
			//
			zip.file("Json").async("string")
			.then(function(jsonText) {		
				ptoz = JSON.parse(jsonText);
				TestShow(ptoz);
			});
		});
	});
}
</script>
</head>
<body>
	<div id="topDiv" style="height: 20%; overflow:auto">
		<p id="tName"></p>
		<p id="tDate"></p>
	</div>

	<div id="controlsDiv">
	</div>

	<div id="pairingsDiv" style="height: 60%; display:none">
	</div>

	<div id="wallChartDiv" style="height: 60%; display:none">
	</div>

	<script>
	loadZip("tournament.ptoz"); // tournament goes here
	</script>
</body>
</html>
